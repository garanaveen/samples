## Task Markup

**Node Class Reference:** [**Task**](https://sdkdocs.roku.com/display/sdkdoc/Task)

The **Task** node class allows the application to launch an asynchronous thread. The most common use of the **Task** node class is as a *content reader*, where the application launches an asynchronous thread that performs an HTTP transfer of a JSON/XML (or other data storage format) file from your server, then converts the returned file to a **ContentNode** node. By setting a field observer for the completed **ContentNode** node created by the **Task** node, your application can use this **ContentNode** node created in the background thread as soon as it is ready to control the layout and behavior of your application, without blocking other SceneGraph rendering operations in the interim.

To demonstrate the basic principles of this content reader **Task** node implementation, we're going to read an XML file with the exact same content meta-data as used in [**ContentNode Markup**](https://github.com/rokudev/samples/tree/master/ux%20components/control) above, and use it in exactly the same way in the application:

 ![img](https://sdkdocs.roku.com/download/attachments/4262849/taskdoc.jpg?version=3&modificationDate=1472836857873&api=v2)

Again, every remote control **OK** key press shows the next **ContentNode** node child node data item. The big difference is how the **ContentNode** node is generated. In this example, the **ContentNode** is generated by launching an asynchronous **Task** node thread to read an XML file containing the **Content Meta-Data** attributes for each data item, and create a **ContentNode** node that contains child **ContentNode** nodes for each data item.

To do this, we need a separate component file for the **Task** node, `contentreader.xml`.

**XML File Content Reader Example**

```
<component name = "ContentReader" extends = "Task" >
 
  <interface>
    <field id = "contenturi" type = "uri" />
    <field id = "content" type = "node" />
  </interface>
 
  <script type = "text/brightscript" >
 
    <![CDATA[
 
    sub init()
      m.top.functionName = "getcontent"
    end sub
 
    sub getcontent()
      content = createObject("roSGNode", "ContentNode")
 
      contentxml = createObject("roXMLElement")
 
      readInternet = createObject("roUrlTransfer")
      readInternet.setUrl(m.top.contenturi)
      contentxml.parse(readInternet.GetToString())
 
      if contentxml.getName()="Content"
        for each item in contentxml.GetNamedElements("item")
          itemcontent = content.createChild("ContentNode")
          itemcontent.setFields(item.getAttributes())
        end for
      end if
 
      m.top.content = content
    end sub
 
    ]]>
 
  </script>
 
</component>
```

For this example, you should look at the server XML file with the **Content Meta-Data** (named `xmlcontent.xml`):

<http://www.sdktestinglab.com/Tutorial/content/xmlcontent.xml>

The xmlcontent.xml file is:

**Server Content Meta-Data XML File**

```
<?xml version = "1.0" encoding = "utf-8" standalone = "yes" ?>
 
<!--********** Copyright 2016 Roku Corp.  All Rights Reserved. **********-->
 
<Content >
  <item title = "Renderable Nodes" />
  <item title = "Z-Order/Parent-Child" />
  <item title = "Animations" />
  <item title = "Events and Observers" />
  <item title = "Typography" />
  <item title = "Control Nodes" />
  <item title = "Lists and Grids" />
  <item title = "Dialogs" />
  <item title = "Widgets" />
  <item title = "Layout/Groups" />
  <item title = "Sliding Panels"  />
  <item title = "Media Playback" />
</Content>
```

Note that this file uses the **Content Meta-Data** attribute `title`. This makes the conversion to a **ContentNode** node in `contentreader.xml` easier because we can use the **setFields()** method to set *all* the fields of a child **ContentNode**node by using the XML parsing getAttributes() call as the argument. If the XML item attributes do not match the **Content Meta-Data** attributes (or custom attribute fields for an extended **ContentNode** node), each XML item attribute must be set explicitly in the content reader XML parsing loop to **Content Meta-Data** attributes.

But the first thing that's mandatory for a content reader **Task** node component file is a custom **<interface>** element:

```
<interface>
  <field id = "contenturi" type = "uri" />
  <field id = "content" type = "node" />
</interface>
```

These two custom fields allow an application to launch an asynchronous content reader thread, by specifying the URI of the XML (or other format) file with the **Content Meta-Data** in the `contenturi` field, and then waiting for the **ContentNode**node to be fully constructed by the thread by observing the `content` field.

Note that the *last* thing done in the `getcontent()` function in `contentreader.xml` is to set the `m.top.content` field to the **ContentNode** node that is now fully constructed from the item attributes in the XML file specified by the `m.top.contenturi` field. This allows the application that launched the **Task** node thread to observe the `content` field, to trigger a callback function to use the **ContentNode** node data items that drives the application appearance and behavior.

If you look at the `contentnodescene.xml` component file in `ContentNodeExample.zip` (see [**ContentNode Markup**](https://github.com/rokudev/samples/tree/master/ux%20components/control)), and compare it to the `taskscene.xml` component file in `TaskExample.zip`, you'll notice they are very similar except for launching the content reader **Task** node, and the callback function triggered when the **Task** node completes the **ContentNode** node: 

**Task Node Content Reader Launch and Callback**

```
sub init()
  ...
  m.readXMLContentTask = createObject("roSGNode", "ContentReader")
  m.readXMLContentTask.observeField("content", "setcontent")
  m.readXMLContentTask.contenturi = "http://www.sdktestinglab.com/Tutorial/content/xmlcontent.xml"
  m.readXMLContentTask.control = "RUN"
  ...
end sub
 
sub setcontent()
  m.content = m.readXMLContentTask.content
  m.contentitems = m.content.getChildCount()
  m.currentitem = 0
  showcontentitem()
end sub
```

First, the **Task** node content reader asynchronous task object is created as `m.readXMLContentTask`. Then the `content` field of the **Task** node is observed, and the location of the XML file containing the **Content Meta-Data** attributes for each of the data items is set as the **Task** node `contenturi` field. Then the control field of the **Task** node is set to `"RUN"`, launching the asynchronous thread. 

When the **ContentNode** node created by the **Task** node is complete, the `setcontent()` callback function is triggered by the change in the **Task** node `content` field. The completed **ContentNode** node in the `content` field is then assigned to the application `m.content` object, and from there the same application operations occur as in `ContentNodeExample.zip`, as described in [**ContentNode Markup**](https://github.com/rokudev/samples/tree/master/ux%20components/control).